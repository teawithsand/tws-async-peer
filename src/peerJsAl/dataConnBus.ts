import { DataConnection } from "peerjs"
import { ClosableSubscribable } from "../util"
import { DefaultEventBus } from "@teawithsand/tws-lts"

/**
 * Subscribable, which can be closed and which can be used to access inner data connection of peerjs.
 */
export interface PeerDataConnSubscribable
	extends ClosableSubscribable<PeerDataConnEvent> {
	readonly conn: DataConnection
}

/**
 * Type of PeerDataConnEvent.
 */
export enum PeerDataConnEventType {
	OPEN = 1,
	CLOSE = 2,
	DATA = 3,
	ERROR = 4,
	ICE_STATE_CHANGE = 5,
	BUS_CLOSE = 6,
}

/**
 * Any event that may be generated by DataConnection.
 */
export type PeerDataConnEvent = {
	conn: DataConnection
} & (
	| {
			type: PeerDataConnEventType.OPEN
	  }
	| {
			type: PeerDataConnEventType.CLOSE
	  }
	| {
			type: PeerDataConnEventType.DATA
			data: any
	  }
	| {
			type: PeerDataConnEventType.ERROR
			error: Error
	  }
	| {
			type: PeerDataConnEventType.ICE_STATE_CHANGE
			state: RTCIceConnectionState
	  }
	| {
			type: PeerDataConnEventType.BUS_CLOSE
	  }
)


/**
 * Constructs PeerDataConnSubscribable from DataConnection.
 * 
 * ## No ownership claimed!
 * 
 * This method does not take ownership over conn object given. You have to free it manually using `.close()`
 * method. Closing PeerDataConnSubscribable returned only frees event listeners, not the conn itself.
 */
export const makePeerDataConnBus = (
	conn: DataConnection
): PeerDataConnSubscribable => {
	const b = new DefaultEventBus<PeerDataConnEvent>()

	let wasBusClosed = false
	let close: () => void

	const onOpen = () => {
		b.emitEvent({
			conn,
			type: PeerDataConnEventType.OPEN,
		})
	}
	const onClose = () => {
		b.emitEvent({
			conn,
			type: PeerDataConnEventType.CLOSE,
		})
		close()
	}
	const onData = (data: any) => {
		b.emitEvent({
			conn,
			type: PeerDataConnEventType.DATA,
			data,
		})
	}
	const onError = (error: Error) => {
		b.emitEvent({
			conn,
			type: PeerDataConnEventType.ERROR,
			error,
		})
	}
	const onIceStateChange = (state: RTCIceConnectionState) => {
		b.emitEvent({
			conn,
			type: PeerDataConnEventType.ICE_STATE_CHANGE,
			state,
		})
	}

	close = () => {
		if (wasBusClosed) return
		wasBusClosed = true

		conn.off("open", onOpen)
		conn.off("close", onClose)
		conn.off("data", onData)
		conn.off("error", onError)
		conn.off("iceStateChanged", onIceStateChange)

		b.emitEvent({
			type: PeerDataConnEventType.BUS_CLOSE,
			conn,
		})
	}

	conn.on("open", onOpen)
	conn.on("close", onClose)
	conn.on("data", onData)
	conn.on("error", onError)
	conn.on("iceStateChanged", onIceStateChange)

	return {
		conn,
		addSubscriber: b.addSubscriber,
		close,
	}
}
